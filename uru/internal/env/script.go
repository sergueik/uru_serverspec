// Author: Jon Maken, All Rights Reserved
// License: 3-clause BSD

package env

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// switcher script templates
var batScript = `@ECHO OFF
REM autogenerated by uru

SET "PATH=%s"
SET "GEM_HOME=%s"
`

var ps1Script = `# autogenerated by uru

$env:PATH = "%s"
$env:GEM_HOME = "%s"
`

var bashScript = `# autogenerated by uru

export PATH=%s
`

var fishScript = `# autogenerated by uru
set -gx PATH %s ^/dev/null
`

// CreateSwitcherScript creates an environment switcher script customized to the
// type of shell calling the uru runtime.
func CreateSwitcherScript(ctx *Context, path *[]string, gemHome string) (scriptName string, err error) {
	scriptType := os.Getenv(`URU_INVOKER`)

	sep := string(os.PathListSeparator)
	script := ``
	switch scriptType {
	case `powershell`:
		script = ps1Script
		scriptName = "uru_lackee.ps1"
	case `batch`:
		script = batScript
		scriptName = "uru_lackee.bat"
	case `bash`:
		script = bashScript
		scriptName = "uru_lackee"
	case `fish`:
		script = fishScript
		scriptName = "uru_lackee.fish"
		sep = " "
	default:
		panic("uru invoked from unknown shell (check URU_INVOKER env var)")
	}
	log.Printf("[DEBUG] switcher script: %s\n", scriptName)

	switcher := filepath.Join(ctx.Home(), scriptName)
	f, err := os.Create(switcher)
	if err != nil {
		panic(fmt.Sprintf("unable to create `%s` switcher script", switcher))
	}
	defer f.Close()

	if runtime.GOOS != `windows` {
		f.Chmod(0755)
	}

	content := ``
	if scriptType == `bash` || scriptType == `fish` {
		if gemHome != `` {
			switch scriptType {
			case "bash":
				script = strings.Join([]string{script, "export GEM_HOME=%s\n"}, ``)
			case "fish":
				script = strings.Join([]string{script, "set -gx GEM_HOME %s\n"}, ``)
			}
			content = fmt.Sprintf(script, strings.Join(*path, sep), gemHome)
		} else {
			// modify the bash script to suppress GEM_HOME creation when nonexistent
			switch scriptType {
			case "bash":
				script = strings.Join([]string{script, "unset GEM_HOME\n"}, ``)
			case "fish":
				script = strings.Join([]string{script, "set -e GEM_HOME\n"}, ``)
			}

			// morph PATH on bash-like and fish environments to *nix style
			if runtime.GOOS == `windows` {
				if scriptType != `fish` {
					sep = `:`
				}
				*path = winPathToNix(path)
			}
			content = fmt.Sprintf(script, strings.Join(*path, sep))
		}
	} else {
		content = fmt.Sprintf(script, strings.Join(*path, sep), gemHome)
	}
	log.Printf("[DEBUG] === CreateSwitcherScript content ===\n%#v\n", content)

	_, err = f.WriteString(content)
	if err != nil {
		panic(fmt.Sprintf("failed to write `%s` switcher script", switcher))
	}

	return
}

// winPathToNix converts a slice of Windows formatted absolute file system
// path strings to a slice of *nix style path strings usable by cygwin
// based shells such as MSYS2 bash on Windows systems.
//
// Windows 8.3 aliases, aka files with `~` in components of the name too long to
// comply legacy DOS 8.3 rules, are not supported. All modern Windows systems
// should be able to correctly handle long file names without the need to interface
// with `GetLongPathNameW` from kernel32.dll. Ensure your PATH contains only long
// path names, not legacy DOS 8.3 short path names.
//
// As the generated paths are not created with a /cygdrive prefix, you may
// need to change cygwin PATH behavior by modifying your cygwin environment's
// /etc/fstab similar to:
//
//     none / cygdrive binary,posix=0,noacl,user 0 0
//
// Example conversion: C:\some\arbitrary\path -> /C/some/arbitrary/path
func winPathToNix(path *[]string) (nix []string) {
	replacements := []string{"\\", "/", "(", "\\(", ")", "\\)", " ", "\\ "}

	for _, p := range *path {
		// pass uru's PATH canaries on through untouched when not in MSYS2
		if (p == canary[0] || p == canary[1]) && !isMsys {
			nix = append(nix, p)
			continue
		}

		// morph and escape problematic chars for bash
		r := strings.NewReplacer(replacements...)

		// morph the Windows volume designator to the format cygwin understands
		parts := strings.Split(r.Replace(p), ":")
		if len(parts) == 1 {
			nix = append(nix, parts[0])
			continue
		}
		parts[0] = fmt.Sprintf("/%s", parts[0])

		nix = append(nix, strings.Join(parts, ``))
	}
	log.Printf("[DEBUG] === winPathToNix path list ===\n%#v\n", nix)

	return
}
